package at.tori.dmr.service

import at.tori.dmr.client.GitLabApiClient
import at.tori.dmr.domain.MergeRequest
import at.tori.dmr.domain.MergeRequestAction
import at.tori.dmr.domain.MergeRequestEvent
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.SupervisorJob
import kotlinx.coroutines.launch
import mu.KotlinLogging
import org.springframework.stereotype.Service

private val logger = KotlinLogging.logger {}

@Service
class CodeReviewService(
  private val gitLabApiClient: GitLabApiClient,
  private val contextBuilderService: ContextBuilderService,
  private val googleChatNotifier: GoogleChatNotifier,
  private val lineByLineReviewService: LineByLineReviewService
) {
  private val reviewScope = CoroutineScope(SupervisorJob() + Dispatchers.Default)

  fun processWebhookEvent(event: MergeRequestEvent) {
    val action = determineAction(event)

    when (action) {
      is MergeRequestAction.Open,
      is MergeRequestAction.Update,
      is MergeRequestAction.Reopen -> {
        reviewScope.launch {
          try {
            performCodeReview(
              projectId = event.project.id,
              mrIid = event.objectAttributes.iid,
              mrUrl = event.project.webUrl + "/-/merge_requests/${event.objectAttributes.iid}"
            )
          } catch (e: Exception) {
            logger.error(e) { "코드 리뷰 수행 중 오류 발생" }
          }
        }
      }

      is MergeRequestAction.Ignore -> {
        logger.debug { "MR 액션 스킵: ${event.objectAttributes.action}" }
      }

      else -> {
        logger.debug { "리뷰가 필요하지 않은 액션: ${event.objectAttributes.action}" }
      }
    }
  }

  suspend fun performCodeReview(projectId: Long, mrIid: Long, mrUrl: String) {
    logger.info { "라인별 코드 리뷰 시작: project=$projectId, MR=$mrIid" }

    try {
      // 1. MR 상세 정보 조회
      val mr = gitLabApiClient.getMergeRequest(projectId, mrIid)
      logger.debug { "MR 조회 완료: ${mr.title}" }

      // 드래프트 MR 스킵
      if (mr.draft || mr.workInProgress) {
        logger.info { "드래프트/WIP MR 스킵: ${mr.title}" }
        return
      }

      // 2. 리뷰 컨텍스트 설정
      val context = contextBuilderService.buildContext(projectId, mr)
      if (context.files.isEmpty()) {
        logger.info { "리뷰할 관련 파일이 없어서 스킵" }
        return
      }

      // 3. 각 라인별 리뷰
      val lineCommentCount = lineByLineReviewService.performLineByLineReview(
        projectId = projectId,
        mrIid = mrIid,
        context = context
      )

      logger.info { "라인별 댓글 작성 완료: ${lineCommentCount}개" }

      // 4. 댓글로 요약본 작성
      val summaryComment = buildString {
        appendLine("# DMR 코드 리뷰 완료")
        appendLine()
        appendLine("라인별 상세 리뷰가 각 파일에 댓글로 작성되었습니다.")
        appendLine()
        appendLine("- 총 ${lineCommentCount}개의 리뷰 댓글")
        appendLine("- 변경된 파일: ${context.files.size}개")
        appendLine("- 추가: +${context.totalAdditions}, 삭제: -${context.totalDeletions}")
        appendLine()
        appendLine("---")
        appendLine("*Generated by DMR: Don't Merge without Review*")
      }

      gitLabApiClient.postMergeRequestNote(projectId, mrIid, summaryComment)

      // 5. 행아웃 알림
      try {
        googleChatNotifier.notifyLineByLineReview(
          context = context,
          lineCommentCount = lineCommentCount,
          mrUrl = mrUrl
        )
      } catch (e: Exception) {
        logger.warn(e) { "Google Chat 알림 전송 실패" }
      }

      logger.info { "코드 리뷰 성공적으로 완료: ${mr.title}" }

    } catch (e: Exception) {
      logger.error(e) { "코드 리뷰 완료 실패: project=$projectId, MR=$mrIid" }

      try {
        val mr = gitLabApiClient.getMergeRequest(projectId, mrIid)
        googleChatNotifier.notifyError(
          projectName = mr.webUrl.substringAfter("://").substringBefore("/merge_requests"),
          mrTitle = mr.title,
          mrUrl = mrUrl,
          error = e.message ?: "Unknown error"
        )
      } catch (notifyError: Exception) {
        logger.error(notifyError) { "오류 알림 전송 실패" }
      }

      throw e
    }
  }

  private fun determineAction(event: MergeRequestEvent): MergeRequestAction {
    val attrs = event.objectAttributes
    val action = attrs.action ?: "unknown"

    return when (action.lowercase()) {
      "open" -> {
        logger.debug { "MR 생성됨, 리뷰 예정" }
        MergeRequestAction.Open(convertToMergeRequest(event))
      }

      "update" -> {
        val hasChanges = event.changes?.let {
          it.title != null || it.description != null ||
              (it.updatedAt?.previous != it.updatedAt?.current)
        } == true

        if (hasChanges) {
          logger.debug { "MR 변경사항 있음, 리뷰 예정" }
          MergeRequestAction.Update(convertToMergeRequest(event))
        } else {
          logger.debug { "MR 업데이트되었으나 중요한 변경사항이 없어서 스킵" }
          MergeRequestAction.Ignore
        }
      }

      "reopen" -> {
        logger.debug { "MR 재오픈됨, 리뷰 예정" }
        MergeRequestAction.Reopen(convertToMergeRequest(event))
      }

      "approved" -> MergeRequestAction.Approved(convertToMergeRequest(event))
      "unapproved" -> MergeRequestAction.Unapproved(convertToMergeRequest(event))
      "merge" -> MergeRequestAction.Merge(convertToMergeRequest(event))
      "close" -> MergeRequestAction.Close(convertToMergeRequest(event))
      else -> {
        logger.debug { "알 수 없거나 스킵하는 액션: $action" }
        MergeRequestAction.Ignore
      }
    }
  }

  private fun convertToMergeRequest(event: MergeRequestEvent): MergeRequest {
    val attrs = event.objectAttributes
    return MergeRequest(
      id = attrs.id,
      iid = attrs.iid,
      title = attrs.title,
      description = attrs.description,
      sourceBranch = attrs.sourceBranch,
      targetBranch = attrs.targetBranch,
      state = attrs.state,
      mergeStatus = attrs.mergeStatus ?: "unknown",
      webUrl = "${event.project.webUrl}/-/merge_requests/${attrs.iid}",
      createdAt = attrs.createdAt ?: "",
      updatedAt = attrs.updatedAt ?: "",
      author = event.user,
      draft = attrs.draft,
      workInProgress = attrs.workInProgress,
      sha = attrs.lastCommit?.id
    )
  }
}
